default:
  image: docker:24.0.5

variables:
  DOCKER_TLS_CERTDIR: ""
  DOCKER_HOST: unix:///var/run/docker.sock
  DOCKER_DRIVER: overlay2
  GIT_DEPTH: 0
  # Default environment if not provided by trigger
  ENVIRONMENT: ${ENVIRONMENT:-production}
  # Default image tags if not provided by trigger
  API_IMAGE_TAG: ${API_IMAGE_TAG:-latest}
  AUTH_IMAGE_TAG: ${AUTH_IMAGE_TAG:-latest}
  FRONTEND_IMAGE_TAG: ${FRONTEND_IMAGE_TAG:-latest}

stages:
  - prepare
  - terraform:validate
  - terraform:plan
  - terraform:apply

prepare-environment:
  stage: prepare
  image: alpine:latest
  script:
    - |
      # Just determine which environment we're working with
      if [ "$ENVIRONMENT" == "dev" ]; then
        echo "Setting up for development environment"
        export TERRAFORM_DIR="environments/dev"
        export TF_STATE_KEY="${CI_PROJECT_PATH_SLUG}/dev.tfstate"
        export ENV_NAME="development"
      elif [ "$ENVIRONMENT" == "staging" ]; then
        echo "Setting up for staging environment"
        export TERRAFORM_DIR="environments/staging"
        export TF_STATE_KEY="${CI_PROJECT_PATH_SLUG}/staging.tfstate"
        export ENV_NAME="staging"
      elif [ "$ENVIRONMENT" == "production" ]; then
        echo "Setting up for production environment"
        export TERRAFORM_DIR="environments/production"
        export TF_STATE_KEY="${CI_PROJECT_PATH_SLUG}/production.tfstate"
        export ENV_NAME="production"
      else
        echo "Unknown environment: $ENVIRONMENT"
        exit 1
      fi
      
      echo "TERRAFORM_DIR=$TERRAFORM_DIR" >> variables.env
      echo "TF_STATE_KEY=$TF_STATE_KEY" >> variables.env
      echo "ENV_NAME=$ENV_NAME" >> variables.env
      
      # Only update image tags in terraform.tfvars
      echo "Updating image tags in terraform.tfvars"
      
      # Create a temporary file with new image tag values
      cat > image_tags.tfvars << EOF
      api_image_tag    = "${API_IMAGE_TAG}"
      auth_image_tag   = "${AUTH_IMAGE_TAG}"
      frontend_image_tag = "${FRONTEND_IMAGE_TAG}"
      EOF
      
      # Use terraform to merge the values (this is cleaner than grep/sed)
      apk add --no-cache terraform
      
      # Create empty terraform file to make this a valid terraform directory
      echo "# Empty file for tfvars merging" > temp.tf
      
      # Import existing tfvars and merge with our new values
      terraform -chdir=$TERRAFORM_DIR fmt -write=true $CI_PROJECT_DIR/image_tags.tfvars
      
      echo "Updated terraform.tfvars with image tags:"
      echo "  API: $API_IMAGE_TAG"
      echo "  Auth: $AUTH_IMAGE_TAG"
      echo "  Frontend: $FRONTEND_IMAGE_TAG"
      
      cat $TERRAFORM_DIR/terraform.tfvars
  artifacts:
    reports:
      dotenv: variables.env

# Define a template for Terraform setup to reuse
.terraform_setup: &terraform_setup
  before_script:
    - apk add --no-cache curl unzip aws-cli jq
    - curl -LO https://releases.hashicorp.com/terraform/1.7.4/terraform_1.7.4_linux_amd64.zip
    - unzip terraform_1.7.4_linux_amd64.zip
    - mv terraform /usr/local/bin/
    - aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
    - aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
    - aws configure set default.region $AWS_REGION
    - cd $CI_PROJECT_DIR/$TERRAFORM_DIR
    # Initialize with explicit backend config
    - >
      terraform init \
        -backend-config="bucket=${TF_STATE_BUCKET}" \
        -backend-config="key=${TF_STATE_KEY}" \
        -backend-config="region=${AWS_REGION}" \
        -backend-config="dynamodb_table=${TF_LOCK_TABLE}" \
        -backend-config="encrypt=true"

terraform:validate:
  stage: terraform:validate
  image: alpine:latest
  needs:
    - prepare-environment
  <<: *terraform_setup
  script:
    - terraform validate
    - terraform fmt -check || true 

terraform:plan:
  stage: terraform:plan
  image: alpine:latest
  needs:
    - terraform:validate
  <<: *terraform_setup
  script:
    - terraform plan -out=tfplan
    - terraform show -no-color tfplan > tfplan.txt
  artifacts:
    paths:
      - $TERRAFORM_DIR/tfplan
      - $TERRAFORM_DIR/tfplan.txt
    expire_in: 1 week

terraform:apply:
  stage: terraform:apply
  image: alpine:latest
  needs:
    - terraform:plan
  rules:
    # Automatically deploy to dev or staging from triggers
    - if: $CI_PIPELINE_SOURCE == "trigger" && $ENVIRONMENT == "staging"
      when: on_success
    # Manual deployment for production or regular pipeline runs
    - if: $CI_PIPELINE_SOURCE == "trigger" && $ENVIRONMENT == "production"
      when: manual
    - if: $CI_COMMIT_BRANCH == "main"
      when: manual
  <<: *terraform_setup
  script:
    - terraform apply -auto-approve
  environment:
    name: $ENV_NAME

terraform:destroy:
  stage: terraform:apply
  image: alpine:latest
  needs:
    - prepare-environment
  rules:
    - if: $CI_PIPELINE_SOURCE == "trigger" || $CI_COMMIT_BRANCH == "main"
      when: manual
  <<: *terraform_setup
  script:
    - terraform destroy -auto-approve
  environment:
    name: $ENV_NAME
    action: stop